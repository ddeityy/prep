# Паттерны

</br>

## Порождающие паттерны
    Беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.
### Фабрика
    Решает проблему создания различных продуктов, без указания конкретных классов продуктов.

### Абстрактная Фабрика
    Решает проблему создания целых семейств связанных продуктов, без указания конкретных классов продуктов.

### Строитель
    Позволяет создавать объекты пошагово.

### Прототип
    Позволяет копировать объекты любой сложности без привязки к их конкретным классам.

### Singleton
    Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

</br>

## Структурные паттерны
    Показывают различные способы построения связей между объектами.

### Adapter
    Позволяет подружить несовместимые объекты.

### Bridge
    Разделяет бизнес-логику или большой класс на несколько отдельных иерархий
    которые потом можно развивать отдельно друг от друга.

### Composite
    Позволяет создавать дерево объектов и работать с ним так же, как и с единичным объектом.

### Decorator
    Позволяет добавлять объектам новые поведения на лету, помещая их в объекты-обёртки.

### Facade
    Предоставляет простой (но урезанный) интерфейс к сложной системе объектов, библиотеке или фреймворку.

### Flyweight
    Экономит память, благодаря разделению общего состояния, вынесенного в один объект, между множеством объектов.

### Proxy
    Объект, который выступает прослойкой между клиентом и реальным сервисным объектом.
    Заместитель получает вызовы от клиента, выполняет свою функцию
    (контроль доступа, кеширование, изменение запроса и прочее), а затем передаёт вызов сервисному объекту.

</br>

## Поведенческие паттерны
    Заботятся об эффективной коммуникации между объектами.

### Chain of Responsibility
    Позволяющий передавать запрос по цепочке потенциальных обработчиков, пока один из них не обработает запрос.

### Command
    Позволяющий заворачивать запросы или простые операции в отдельные объекты.

### Iterator
    Позволяющий последовательно обходить сложную коллекцию, без раскрытия деталей её реализации.

### Mediator
    Который упрощает коммуникацию между компонентами системы.

### Memento
    Позволяющий делать снимки внутреннего состояния объектов, а затем восстанавливать их.

### Observer
    Позволяет объектам оповещать другие объекты об изменениях своего состояния.

### State
    Позволяющий динамически изменять поведение объекта при смене его состояния.

### Strategy
    Выносит набор алгоритмов в собственные классы и делает их взаимозаменимыми.

### Visitor
    Позволяет добавить новую операцию для целой иерархии классов, не изменяя код этих классов.

### Template
    Задающий скелет алгоритма в суперклассе и заставляющий подклассы реализовать конкретные шаги этого алгоритма.

</br>

## Отказоустойчивые паттерны
    * Сокращение времени простоя сервисов.
    * Лучшая изоляция от сбоев.
    * Повышение производительности системы.
    * Повышение удовлетворенности пользователей.

### Circuit Breaker
    * Закрыт - все реквесты проходят
    * Открыт - все реквесты дропаются
    * Полуоткрыт - после "таймаута сброса" проходит фиксированное кол-во реквестов
        для теста восстановления.
        Если всё хорошо - переход в закрытое состояние.

### Bulkhead
    Изоляция путем разделения ресурсов для поддержания стабильности и доступности.
    
    Изоляция на уровне ресурсов:
        Этот тип изоляции позволяет распределять ресурсы,
        такие как потоки и пулы соединений, между различными службами,
        гарантируя, что проблемы в одной службе не повлияют на другие.

    Изоляция на уровне процессов:
        Эта стратегия направлена на выделение сервисов в отдельные процессы или контейнеры.
        Если один из сервисов выходит из строя, остальные продолжают функционировать без ущерба.

### Timeout & Retry
    Определённый таймаут реквеста.
    Определённое кол-во повторных попыток.
    Экспоненциальная задержка между попытками.
    Идемпотентность.

### Rate Limiter
    Паттерн отказоустойчивости в распределенных системах
    предназначенный для защиты сервисов от чрезмерной нагрузки
    путем контроля скорости поступления запросов.

    Стратегии:
        * Фиксированное окно:
            Время разбито на окна.
            Есть лишь N кол-во реквестов за слот.
        * Скользящее окно
            Время не разбито на окна.
            Есть лишь N кол-во реквестов за отрезок времени с последнего реквеста.
        * Token Bucket
            N кол-во токенов в ведре.
            Все реквесты попадают в ведро.
            1 реквест = 1 токен.
            Токены медленно восстанавливаются.
            Если токенов нет - реквест дропается.
        * Leaky Bucket
            Есть ведро с максимальным кол-вом реквестов.
            Реквесты отдаются на выполнение с опр. скоростью.
            При переполнении ведра все новые реквесты дропаются.
            
### Fallback
    Позволяет возвращать альтернативный ответ, так называемый fallback response, когда сервис не может обработать запрос.
    Возврат кэшированных данных, значений по умолчанию
    или выдача удобного для пользователя сообщения об ошибке.

### Health Check
    Эндпоинт со статусом микросервиса.
